// Use grammar from minispec src
// Original Author: Daniel Sanchez
// Translater: Krittamate Tiankanon

// Syntax for grammar file ( used by boomza's greedy parsergen)
// // stands for  one line comment
// all word  or operators separated by spacebar (too lazy to make parser generator)
// $case_insensitive_Name is token type
// name_case inssensitive is non terminal
// , is concatenation operation e , f try to match e then f
// | is alternative operation e | f try to match e and if it fails, try match f
// * is repetition operation  e * try to match e >=0 time until it fails to match
// ? is optional operation  e ? try to match e exactly 1 time if fail, just ignore the terminal
// + is repetition operation >=1 e + is equivalent to e , e *
// Can also use () for grouping but still need spacebar between ( and the rest and )
// Assigning non terminal use this Syntax
// name = Production_rule
// Order of operation: () >> +*? >> , >> |


// lower Case identifier + upper + dollar are part of token

identifier = $Lower_identifier | $Upper_identifier
any_identifier = $Lower_identifier | $Upper_identifier | $Dollar_identifier

//literals


//args for function declaring
arg = expression
args = $left_paren_punc , ( arg , ( $comma_punc , arg ) * ) ? , $right_paren_punc
argFormal = type , $Lower_identifier
argFormals = $left_paren_punc , ( argFormal , ( $comma_punc , argFormal ) * ) ? , $right_paren_punc

// Types format
type = $upper_identifier , params ? // This is to declare varaible with types

// param for inputting to type delaration
params = $sharp_punc , $left_paren_punc , ( param , ( $comma_punc , param ) * ) ? , $right_paren_punc
param = expression | type 
paramFormals = $sharp_punc , $left_paren_punc , ( paramFormal , ( $comma_punc , paramFormal ) * ) ? , $right_paren_punc
paramFormal = type , $Lower_identifier | $type_keyword , $Upper_identifier | param


//The rest
the_rest = . // basically all other things outside module
// including typeDefs, funcitondefs, and Global Varaibledef

// Imports 
importDecl = $import_keyword , identifier , ( $comma_punc , identifier ) * , $semicolon_punc
bsvImportDecl = $bsvimport_keyword , $upper_identifier , ( $comma_punc , $upper_identifier ) * , $semicolon_punc

//type defs
typeDecl = typeDefSynonym  | typeDefEnum  | typeDefStruct
typeId = $Upper_identifier , paramFormals ? // this is to declare what type alias to
typeDefSynonym = $typedef_keyword , type , typeId , $semicolon_punc
typeDefEnum = $typedef_keyword , $enum_keyword , $left_brace_punc , typeDefEnumElement , ( $comma_punc , typeDefEnumElement ) * , $right_brace_punc , $upper_identifier , $semicolon_punc
typeDefEnumElement = $upper_identifier , ( $eq_op , )

packageStmt = importDecl | bsvImportDecl | typeDecl | moduleDef 
packageDef = packageStmt * // The outer most level
start = packageDef